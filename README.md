# Goal

Demonstrate a simple way of adding per-request contextual logging at the go-kit 
endpoint layer. 

# How

Go-kit provides a useful endpoint abstraction that can easily be wrapped by a logging middleware.
This logging middleware can be applied across all endpoints using a single implementation because of the endpoint
interface. Since this middleware is being applied at the endpoint level the request and response are received/responded
as type `interface{}`. This makes it difficult to log specific fields/values that are contained within the request
and response objects. This can be overcome by defining a simple interface that can be implemented by each endpoint 
request and response type. Here is the interface (extracted from [pkg/eplogger/eplogger.go](pkg/eplogger/eplogger.go):

```go
type AppendKeyvalser interface {
	AppendKeyvals(keyvals []interface{}) []interface{}
}
```

Now we need to implement the interface on the request/response types that we want to have logged within the 
middleware (extraced from [pkg/endpoint/endpoint.go](pkg/endpoint/endpoint.go):

```go
// SumRequest collects the request parameters for the Sum method.
type SumRequest struct {
	A int `json:"a"`
	B int `json:"b"`
}

// AppendKeyvals implements AppendKeyvalser to return keyvals specific to SumRequest for logging
func (s SumRequest) AppendKeyvals(keyvals []interface{}) []interface{} {
	return append(keyvals,
		"SumRequest.A", s.A,
		"SumRequest.B", s.B)
}
```

Now the eplogger package ([pkg/eplogger/eplogger.go](pkg/eplogger/eplogger.go)) can be used as a go-kit middleware to take advantage of the AppendKeyvalser
interface:

```go

// Create a logger that will be used for normal logging and another for error logging
errLogger := level.Error(logger)
infoLogger = level.Info(logger)

// Wrap an endpoint with the middleware
epWithMw := LoggingMiddleware(infoLogger, errLogger)(endpoint)
```

Now, every time a request passes through an endpoint, keyvals specific to `request` and `response` will be logged
if the `AppendKeyvalser` interface is implemented. If the interface is not implemented then the log will just be
written without any information about the `request` and `response` objects.

> Note: The structure of this project was generated by [kit](https://github.com/kujtimiihoxha/kit), therefore, there is 
much more code in this repo than is absolutely necessary for this example. However, it provides an example of a fully 
usable [go-kit](https://github.com/go-kit/kit) service.

# Running the code

Start up the service

```bash
go run cmd/main.go 
```

Send in a `sum` and `multiply` request

```bash
$ curl -d '{"a":2,"b":3}' localhost:8081/sum
{"r":5,"err":null}
$ curl -d '{"a":2,"b":3}' localhost:8081/multiply
{"r":6,"err":null}
```

See the keyvals printed for each request/response (the keys start with `SumRequest.`, `SumResponse.`, `MultiplyRequest.`, and `MultiplyResponse.`):

```bash
ts=2019-06-12T20:01:41.671115Z caller=level.go:150 method=Sum level=info SumRequest.A=2 SumRequest.B=3 SumResponse.R=5 SumResponse.Err=null transport_error=null took=11.08µs
ts=2019-06-12T20:01:45.862347Z caller=level.go:150 method=Multiply level=info MultiplyRequest.A=2 MultiplyRequest.B=3 MultiplyResponse.R=6 MultiplyResponse.Err=null transport_error=null took=6.548µs
```
