# Goal

Demonstrate a simple way of adding per-request contextual logging at the go-kit 
endpoint layer. 

# How

Go-kit provides a useful endpoint abstraction that can easily be wrapped by a logging middleware.
This logging middleware can be applied across all endpoints using a single implementation because of the endpoint
interface. Since this middleware is being applied at the endpoint level the request and response are received/responded
as type `interface{}`. This makes it difficult to log specific fields/values that are contained within the request
and response objects. This can be overcome by defining a simple interface that can be implemented by each endpoint 
request and response type. Here is the interface (extracted from [pkg/eplogger/eplogger.go](pkg/eplogger/eplogger.go):

```go
type LoggingKeyvalser interface {
	LoggingKeyvals() (keyvals []interface{})
}
```

Now we need to implement the interface on the request/response types that we want to have logged within the 
middleware (extraced from [pkg/endpoint/endpoint.go](pkg/endpoint/endpoint.go):

```go
// SumRequest collects the request parameters for the Sum method.
type SumRequest struct {
	A int `json:"a"`
	B int `json:"b"`
}

// LoggingKeyvals implements LoggingKeyvalser to return keyvals specific to SumRequest for logging
func (s SumRequest) LoggingKeyvals() []interface{} {
	return []interface{}{"SumRequest.A", s.A, "SumRequest.B", s.B}
}
```

Now we define the logging middleware to take advantage of this 
interface (extracted from [pkg/eplogger/eplogger.go](pkg/eplogger/eplogger.go)):

```go
// LoggingMiddleware returns an endpoint middleware that logs the
// duration of each invocation, the resulting error (if any), and
// keyvals specific to the request and response object if they implement
// the LogKeyvalsAdder interface.
func LoggingMiddleware(logger log.Logger) endpoint.Middleware {
	return func(next endpoint.Endpoint) endpoint.Endpoint {
		return func(ctx context.Context, request interface{}) (response interface{}, err error) {
			defer func(begin time.Time) {
				// Check if request implements the LoggingKeyvalser interface
				if l, ok := request.(LoggingKeyvalser); ok {
					// Update logger to contain keyvals specific to request
					logger = log.With(logger, l.LoggingKeyvals()...)
				}
				// Check if response implements the LoggingKeyvalser interface
				if l, ok := response.(LoggingKeyvalser); ok {
					// Update logger to contain keyvals specific to request
					logger = log.With(logger, l.LoggingKeyvals()...)
				}
				logger.Log("transport_error", err, "took", time.Since(begin))
			}(time.Now())
			return next(ctx, request)
		}
	}
}
```

Now every time a request passes through an endpoint keyvals specific to `request` and `response` will be logged
if the `LogKeyvalsAdder` interface is implemented. If the interface is not implemented then the log will just be
written without any information about the `request` and `response` objects.

> Note: The structure of this project was generated by [kit](https://github.com/kujtimiihoxha/kit), therefore, there is 
much more code in this repo than is absolutely necessary for this example. However, it provides an example of a fully 
usable [go-kit](https://github.com/go-kit/kit) service.

# Running the code

Start up the service

```bash
go run cmd/main.go 
```

Send in a `sum` and `multiply` request

```bash
$ curl -d '{"a":2,"b":3}' localhost:8081/sum
{"r":5,"err":null}
$ curl -d '{"a":2,"b":3}' localhost:8081/multiply
{"r":6,"err":null}

```

See the keyvals printed for each request/response (the keys start with `SumRequest.`, `SumResponse.`, `MultiplyRequest.`, and `MultiplyResponse.`):

```bash
ts=2019-06-07T05:02:48.01564Z caller=eplogger.go:32 method=Sum SumRequest.A=2 SumRequest.B=3 SumResponse.R=5 SumResponse.Err=null transport_error=null took=13.38µs
ts=2019-06-07T05:02:49.198004Z caller=eplogger.go:32 method=Multiply MultiplyRequest.A=2 MultiplyRequest.B=3 MultiplyResponse.R=6 MultiplyResponse.Err=null transport_error=null took=24.711µsv
```